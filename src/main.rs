use std::time::Instant;

use crate::{mind::mlp::MLP, engine::state::State};

mod engine;
mod mind;

fn main() {
    let mut state = State {nodes: vec![]};

    let xs1 = vec![(2.0f32, "x11"), (3.0f32, "x12"), (-1.0f32, "x13")];
    let xs2 = vec![(3.0f32, "x21"), (-1.0f32, "x22"), (0.5f32, "x23")];
    let xs3 = vec![(0.5f32, "x31"), (1.0f32, "x32"), (1.0f32, "x33")];
    let xs4 = vec![(1.0f32, "x41"), (1.0f32, "x42"), (-1.0f32, "x43")];

    let xs = vec![xs1, xs2, xs3, xs4];
    // let xs = vec![xs1, xs2];
    let ys = vec![1.0f32, -1.0f32, -1.0f32, 1.0f32];
    // let ys = vec![1.0f32, -1.0f32];

    let mlp = MLP::new(3, vec![4, 4, 4, 1], &mut state);

    let prev_state: Vec<f32> = vec![0.39566404, -0.74542826, 1.1424747, 0.75085133, -0.7070376, -0.21252042, -0.5629296, 0.4108628, 0.729035, -0.072931334, -0.24460071, 0.9060674, 0.57127887, 0.47683445, 0.91553694, -0.67058295, -0.1581843, 0.7421135, -0.178423, 0.112205274, -0.028045533, -0.6433174, -0.8742118, -0.012232775, -0.53196955, -0.9206642, -0.6430638, 0.13993894, 0.10648294, -1.1449425, -0.80958563, -0.1265842, 0.51943785, 1.005324, -0.4456088, -0.7949482, 0.9939592, -0.24484554, 0.73380035, 1.5567919, -0.021602023, -1.1349707, -0.59050256, 0.057750348, -0.38787588, 0.43488076, 3.3093073, -0.7201884, 0.39324677, 0.14897077, 0.02067839, 2.3086352, 2.921932, 0.5130827, 0.067751974, 2.3220508, 2.9451556, 1.4588857, 3.8570209, -4.0145187, -0.5320828];
    mlp.set_state(prev_state, &mut state);

    let start = Instant::now();
    mlp.train(&xs, &ys, 10000, 0.001, &mut state);
    let duration = start.elapsed();

    println!("duration: {:?}", duration);
    println!("state:\n{:?}", mlp.get_state(&state));
}

#[macro_export]
macro_rules! str {
    () => {
        String::new()
    };
    ($x:expr $(,)?) => {
        ToString::to_string(&$x)
    };
}
